<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RiKa0-0</title>
  
  <subtitle>RiKa0-0</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rika0-0.github.io/"/>
  <updated>2020-04-07T10:33:21.629Z</updated>
  <id>http://rika0-0.github.io/</id>
  
  <author>
    <name>寒光君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法期末试题摘录</title>
    <link href="http://rika0-0.github.io/2020/04/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98%E6%91%98%E5%BD%95/"/>
    <id>http://rika0-0.github.io/2020/04/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98%E6%91%98%E5%BD%95/</id>
    <published>2020-04-07T06:36:37.000Z</published>
    <updated>2020-04-07T10:33:21.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ul><li><p>算法的五个重要特性：有穷性、确定性、可行性、0个或多个输入、一个或多个输出。</p></li><li><p>算法的复杂性有 时间复杂度 和 空间复杂度 之分，衡量一个算法好坏的标准是 时间复杂度高低 。</p></li><li><p>某一个问题可用动态规划算法求解的显著特征是 该问题具有最有子结构性质。</p></li><li><p>用回溯法解问题时，应明确定义问题的解空间，问题的解空间至少应包含  一个（最优）解。</p></li><li><p>动态规划算法的基本思想是将待求解问题分解成若干子问题。</p></li><li><p>以深度优先方式系统搜索问题解的算法称为 回溯法。</p></li><li><p>0-1背包问题的回溯算法所需的计算时间为O(n*2^n)，用动态规划算法所需的计算时间为O(min{nc,2^n})</p></li><li><p>动态规划算法的两个基本要素是 最优子结构 和 重叠子问题、</p></li><li><p>二分搜索法是利用动态规划法来实现的算法。</p></li></ul><h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><ol><li>设计动态规划法的步骤<br>1、问题具有最有子结构性质；<br>2、构造最优值我递归关系表达式；<br>3、最优值的算法描述；<br>4、构造最优解<h1 id="算法设计思路"><a href="#算法设计思路" class="headerlink" title="算法设计思路"></a>算法设计思路</h1></li></ol><h2 id="分治法基本策略"><a href="#分治法基本策略" class="headerlink" title="分治法基本策略"></a>分治法基本策略</h2><pre class=" language-c++"><code class="language-c++">divide-and-conquer(P){if ( | P | <= n0) adhoc(P); //解决小规模的问题divide P into smaller subinstances P1,P2,...,Pk˗//分解问题for (i=1,i<=k,i++)yi=divide-and-conquer(Pi); //递归的解格子问题return merge(y1,...,yk); //将各子问题的解合并为原问题的解}</code></pre><h3 id="二分搜索技术"><a href="#二分搜索技术" class="headerlink" title="二分搜索技术"></a>二分搜索技术</h3><h1 id="程序题"><a href="#程序题" class="headerlink" title="程序题"></a>程序题</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;填空题&quot;&gt;&lt;a href=&quot;#填空题&quot; class=&quot;headerlink&quot; title=&quot;填空题&quot;&gt;&lt;/a&gt;填空题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法的五个重要特性：有穷性、确定性、可行性、0个或多个输入、一个或多个输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;算
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法精要总复习（updating）</title>
    <link href="http://rika0-0.github.io/2020/04/06/%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A6%81%E6%80%BB%E5%A4%8D%E4%B9%A0updating/"/>
    <id>http://rika0-0.github.io/2020/04/06/%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A6%81%E6%80%BB%E5%A4%8D%E4%B9%A0updating/</id>
    <published>2020-04-06T15:01:39.000Z</published>
    <updated>2020-04-07T06:34:37.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="算法的复杂性分析"><a href="#算法的复杂性分析" class="headerlink" title="算法的复杂性分析"></a>算法的复杂性分析</h2><h3 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h3><ul><li>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。<br>一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。</li></ul><ol><li>推导大O阶方法   </li></ol><p>如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？  </p><p>用常数1取代运行时间中的所有加法常数。  </p><p>在修改后的运行次数函数中，只保留最高阶项。 </p><p>如果最高阶项存在且不是1，则去除与这个项相乘的常数。 </p><p>得到的最后结果就是大O阶。</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><ul><li><p>常数阶</p><pre class=" language-c++"><code class="language-c++">int sum = 0, n = 100;printf(“I love you.com\n”);printf(“I love you.com\n”);printf(“I love you.com\n”);printf(“I love you.com\n”);printf(“I love you.com\n”);printf(“I love you.com\n”);sum = (1+n)*n/2;</code></pre><p>第一条就说明了所有加法常数给他个O(1)即可</p></li><li><p>线性阶   </p></li></ul><p>一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长.<br>这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。</p><pre class=" language-c++"><code class="language-c++">int i , n = 100, sum = 0;for( i=0; i < n; i++ ){    sum = sum + i;}</code></pre><ul><li>平方阶<br>n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。<pre class=" language-c++"><code class="language-c++">int i, j, n = 100;for( i=0; i < n; i++ ){  for( j=0; j < n; j++ )  {      printf(“I love FishC.com\n”);  }}</code></pre></li><li>对数阶<br>由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。<br>于是由2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。<pre class=" language-c++"><code class="language-c++">int i = 1, n = 100;while( i < n ){  i = i * 2;}</code></pre></li><li>函数调用的时间复杂度分析<br><img src="https://upload-images.jianshu.io/upload_images/4807654-9d3b7f58b405a618.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/659/format/webp" alt=""></li></ul><h3 id="空间复杂性"><a href="#空间复杂性" class="headerlink" title="空间复杂性"></a>空间复杂性</h3><ul><li>算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。  </li><li>通常，我们都是用“时间复杂度”来指运行时间的需求，是用“空间复杂度”指空间需求。<br>当直接要让我们求“复杂度”时，通常指的是时间复杂度。<br>显然对时间复杂度的追求更是属于算法的潮流！<h3 id="渐近分析中的5个符号"><a href="#渐近分析中的5个符号" class="headerlink" title="渐近分析中的5个符号"></a>渐近分析中的5个符号</h3></li><li>渐近精确界记号：ΘΘ（big-theta）</li><li>渐近上界记号：OO(big-oh)</li><li>渐近下界记号：ΩΩ(big-omege)</li><li>非渐近紧确上界：o(小-oh)</li><li>非渐近紧确下界：ω(小-omege)<h1 id="第二章-递归与分治策略"><a href="#第二章-递归与分治策略" class="headerlink" title="第二章 递归与分治策略"></a>第二章 递归与分治策略</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;h2 id=&quot;算法的复杂性分析&quot;&gt;&lt;a href=&quot;#算法的复杂性分析&quot; class=&quot;headerlink&quot; title=&quot;算法的复杂
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法精要总复习（updating）</title>
    <link href="http://rika0-0.github.io/2020/04/06/%E5%BF%85%E4%BC%9A%E7%AE%97%E6%B3%95/"/>
    <id>http://rika0-0.github.io/2020/04/06/%E5%BF%85%E4%BC%9A%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-06T15:01:39.000Z</published>
    <updated>2020-04-07T10:27:13.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h2 id="实现二分搜索技术"><a href="#实现二分搜索技术" class="headerlink" title="实现二分搜索技术"></a>实现二分搜索技术</h2><ul><li>范例：  <pre class=" language-c++"><code class="language-c++">#include <iostream>       using namespace std;   </code></pre></li></ul><p>template<class Type><br>int BinarySearch(Type a[],const Type&amp; x,int n);  </p><p>int main()<br>{<br>    int x = 6;<br>    int a[10];<br>    for(int i=0; i&lt;10; i++)  //初始化一串数组<br>    {<br>        a[i] = i + 1;<br>    }<br>    cout&lt;&lt;BinarySearch(a,x,10)&lt;&lt;endl;  //a数组，x搜索的值，10为长度<br>    return 0;<br>}  </p><p>template<class Type><br>int BinarySearch(Type a[],const Type&amp; x,int n)<br>{<br>    int left = 0;<br>    int right = n-1;<br>    while(left&lt;=right)  //规定区间<br>    {<br>        int mid = (left + right)/2;  //每次取中间的的值<br>        if(x == a[mid])<br>        {<br>            return mid;  //返回下标<br>        }<br>        if(x&gt;a[mid])  //如果小于指定值，<br>        {<br>            left = mid + 1;  //中间位等于最小位<br>        }<br>        else  //如果大于指定值<br>        {<br>            right = mid - 1;  //中间位等于最大位<br>        }<br>    }  </p><pre><code>return -1; }```</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;h2 id=&quot;分治法&quot;&gt;&lt;a href=&quot;#分治法&quot; class=&quot;headerlink&quot; title=&quot;分治法&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
